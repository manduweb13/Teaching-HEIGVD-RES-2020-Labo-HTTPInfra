# Laboratoire infrastructure HTTP

## Etape 1: Serveur HTTP statique avec Apache httpd

AprÃ¨s avoir forkÃ© le repo du laboratoire, nous allons crÃ©er un container Docker Ã  partir de l'image php sur docker.hub et contenant un serveur httpd fonctionnel. 

### Build de l'image, run du container et test d'accÃ¨s depuis un browser
Nous allons d'abord crÃ©er la structure du contenu statique que nous voulons afficher sur notre serveur. Pour celÃ  nous allons choisir un template bootstrap dÃ©nichÃ© sur internet et customisÃ© pour prÃ©senter le cours RES. Nous allons placer ce contenu dans un dossier cotent.

Nous allons ensuite crÃ©er un Dockerfile dans le mÃªme dossier que le dossier content et allons y spÃ©cifier le contenu suivant. Nous utiliserons une image Docker contenant PHP couplÃ© Ã  un serveur Apache.

```
#On rÃ©cupÃ¨re l'image sur dockerhub
FROM php:7.2-apache
#Copie du contenu du dossier content (filesystem local) dans le rÃ©pertoire du serveur web de l'image
COPY /content/ /var/www/html/
```

GÃ©nÃ©ration de l'image avec la commande en Ã©tant dans le rÃ©pertoire du Dockerfile.
```
docker build --tag php_httpd .
```

Lancement d'un container avec l'image crÃ©Ã©e et Ã©coutant sur le port 8080. On a du port forwarding du port 8080 de l'hÃ´te sur le port 80 du container.

```
docker run -d -p 8080:80 php_httpd
```

On peut ensuite y accÃ©der en tappant 192.168.99.100:8080 dans le navigateur. L'adresse ip est celle-ci car j'utilise Docker Toolbox sur mon pc pour l'utiliser conjointement avec mes machines virtuelles. L'IP d'accÃ¨s peut ainsi varier selon la configuration du poste.

### Fichier de configuration Apache

Les fichier de configurations sont accessible dans le rÃ©pertoire /etc/apache2 et on s'intÃ©resse pour le moment plus spÃ©cifiquement aux fichiers apache2.conf et /sites-available/000-default.conf.

Le premier est le point central de toute la configuration du serveur Apache. En effet, la configuration est splitÃ©e en plusieurs fichiers de configuration. Ce fichier fait le lien entre eux.

Le 2Ã¨me contient les configuration propres aux hÃ´tes virtuels et aux chemin d'accÃ¨s aux racines des diffÃ©rents sites ainsi qu'aux ports qui leurs sont attribuÃ©s.


## Etape 2: Serveur HTTP dynamique avec express.js
Dans cette partie, nous allons Ã©crire une application Node.js et apprendre Ã  utiliser Postman pour tester notre application.

### RÃ©cupÃ©ration de l'image et Dockerfile
Nous allons utiliser l'image node:12.16.3 qui est la derniÃ¨re version stable et est disponible sur hub.docker.

Le Dockerfile se dÃ©cline comme ceci.
```
FROM node:12.16.3
COPY src /opt/app

CMD ["node", "/opt/app/index.js"]
```

### Initialisation de l'application NodeJS

Dans le rÃ©pertoire src que nous allons copier dans notre container, nous allons lancer la commande suivante pour initialiser l'application. Mais avant celÃ , il nous faut installer NodeJS sur notre machine en tÃ©lÃ©chargeant l'installer sur le [site de NodeJS](https://nodejs.org/en/download/).
```
npm init
```

Cette commande va gÃ©nÃ©rer un fichier package.json qui contient les informations propres Ã  notre application.

La commande suivante va ajouter la dÃ©pendance chance.js pour la gÃ©nÃ©ration de contenu alÃ©atoire dans le package.json.

```
npm install --save chance
```

La suite de commandes prÃ©cÃ©dentes gÃ©nÃ¨re le package.json suivant.

```
{
  "name": "presences",
  "version": "0.1.0",
  "description": "Une application de gestion des presences",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Julien Brunisholz",
  "license": "ISC",
  "dependencies": {
    "chance": "^1.1.4"
  }
}

```

On fait un build de l'image et on lance un container, ceci va avoir pour effet d'afficher un nom alÃ©atoire dans notre console. Notre container s'arrÃªte dÃ¨s la fin du script du coup pas moyen pour le moment de l'accÃ©der depuis un navigateur par exemple.

### Implementation d'un serveur HTTP en NodeJS

#### Installation du framework Express.js et test de fonctionnement

On lance la commande suivante pour installer le framework dans notre rÃ©pertoire src.

```
npm install --save express
```

Le rÃ©pertoire node_modules contient les dÃ©pendances des diffÃ©rents packages installÃ©s, en gÃ©nÃ©ral, on dÃ©fini ce dossier dans le fichier .gitignore car il est volumineux.

On insÃ¨re ensuite le code suivant dans notre index.js.

```Node.js
var Chance = require('chance');
var chance = new Chance();

var express = require('express');
var app = express();

app.get('/', function(req, res) {
        res.send("Hello RES");
});

app.listen(3000, function () {
        console.log('Accepting HTTP requests on port 3000!');
});
```

On va donc Ã©couter sur le port 3000 avec notre application et dÃ¨s qu'une requÃªte HTTP (GET) venant d'un client est reÃ§ue avec comme contenu '/', on retourne un message.

Pour lancer notre application en local
```
node index.js
```

Pour se connecter en telnet Ã  notre application
```
>telnet localhost 3000
>GET / HTTP/1.0
```

#### CrÃ©ation d'une premiÃ¨re petite application en NodeJs

Pour se familiariser avec NodeJs, le framework Express.js et l'outil chance.js, nous avons modifier l'index.js pour qu'il renvoie une liste au format json de membres avec une liste de prÃ©sences.

```Node.js
var Chance = require('chance');
var chance = new Chance();

var express = require('express');
var app = express();

app.get('/', function(req, res) {
        res.send( generatePresencesAndMembers() );
});

app.listen(3000, function () {
        console.log('Accepting HTTP requests on port 3000!');
});

// GÃ©nÃ¨re un nombre de prÃ©sence alÃ©atoires pour des membres
function generatePresencesAndMembers() {
        var numberOfPresences = bordedRandomNumber(1,4);
        var numberOfMembers = bordedRandomNumber(1,5);

        //Un membre a un nom, un prÃ©nom, un sexe et une date de naissance et un tableau //de prÃ©sences
        var members = [];


        for(var i = 0; i < numberOfMembers; i++) {
                var gender = chance.gender();
                var firstName = chance.first({gender: gender});
                var lastName = chance.last({gender: gender});
                var birthDate = chance.date({string: true, american: false});

                var presences = [];;

                for(var j = 0; j < numberOfPresences; j++) {
                        presences.push({
                                date: chance.date({string: true, american:false}),
                                eventLocation: chance.city()
                        });
                }

                members.push({
                                firstName: firstName,
                                lastName: lastName,
                                gender: gender,
                                birthDate: birthDate,
                                presences: presences
                        });
        }

        console.log(numberOfMembers);
        console.log(numberOfPresences);

        return members;

}

// Retourne un nombre alÃ©atoire entre min et max
function bordedRandomNumber(minV, maxV) {
        return chance.integer({
                min: minV,
                max: maxV
        });
}
```

## Step 3: Reverse proxy with apache (static configuration)
Cette partie a pour but la mise en place d'un reverse proxy, c'est à dire un point central d'accès à notre infrastructure web. Ce reverse proxy va en effet recevoir les différentes requêtes adressées à notre infrastructure et les dispatcher vers la bonne destination interne.

### Démarrage des container et tests de fonctionnement
Nous allons ici démarrer des container à partir des images créées dans les deux étapes précédentes.

`
>docker run -d --name apache_static php_httpd
>docker run -d --name express_dynamic express_presences

`

Ensuite, grâce à la commande docker inspect pour chaque container, on trouve (dans NetworkSettings/IPAddress) l'adresse IP donnée au container.

* 172.17.0.2 pour apache_static
* 172.17.0.2 pour express_dynamic

Utilisant powershell sous windows comme interface de ligne de commande, cette commande correspond à un grep -i en bash
`Powershell
>docker inspect apache_static | Select-String -Pattern IPAddress
`

`bash
>docker inspect apache_static | grep -i IPAddress
`
Ce qui nous donne la sortie suivante
`
"SecondaryIPAddresses": null,
"IPAddress": "172.17.0.2",
	"IPAddress": "172.17.0.2",
`

On peut ensuite tester nos container. Pour ceci, nous utilisons la commande suivante.

`
>docker-machine ssh
`
qui nous permet de nous connecter à notre machine virtuelle docker pour atteindre nos container. En effet, ceux-ci ne sont pas accessibles depuis l'extérieur du fait que nous n'avons pas fait de port forwarding.

On lance ensuite une connexion telnet à chaqun des container puis on leur envoie une requête HTTP.

`
GET / HTTP/1.0
`

### Configuration du Reverse Proxy et routage des requêtes

Dans cette configuration, les adresses ip des containers sont insérées en dur dans la configuration. Cette manière de faire n'est pas souhaitable si on souhaite obtenir une solution robuste. En effet, les adresses ip assignées aux container peuvent varier.

Notre reverse proxy va être implémenté dans un container Docker basé sur la même image que pour le contenu statique que nous avons créé auparavant. L'image php:7.2-apache.

La configuration voulue pour le reverse proxy doit nous permettre:

* d'atteindre le site statique dans le container apache_static en spécifiant la requête
`
GET / HTTP/1.0
Host: demo.res.ch
`
* d'atteindre le site dynamique (liste de présence) du container express_dynamic via la requête
`
GET /api/presences/ HTTP/1.0
`
#### configuration Dockerfile et des fichiers de configuration Apache
Nous allons créer un nouveau répertoire apache-reverse-proxy qui va contenir les fichiers nécessaires à la création de notre image personnalisée pour le reverse proxy.

Tout d'abord, un petit mot sur la structure de la configuration d'Apache.
/etc/apache2, est le répertoire contenant les fichiers de configuration du service Apache. Ses sous-dossiers importants pour notre configuration sont :

* mods-available : les modules disponibles
* mods-enabled : les modules activés via l'utilitaire a2enmod
* sites-available : les sous-sites disponibles
* sites-enabled : les sous-sites activés via l'utilitaire a2ensite

Le Dockerfile de notre image sera le suivant.

``
FROM php:7.2-apache                                                                                                                                                                                                                                                         COPY conf/ /etc/apache2                                                                                                                                                                                                                                                     RUN a2enmod proxy proxy_http                                                                                                          RUN a2ensite 000-* 001-*
``
La commande COPY va copier les fichiers de configuration Apache dans le répertoire de configuration du container à sa création. Ici il s'agit de copier le contenu du dossier sites-available (sous-dossier de conf) dans le container pour définir les 2 sites :
* 000-default.conf qui définit le virtual host par défaut. On le défini comme ça pour que le client, s'il envoie une requête sans définir l'en-tête "Host:", n'arrive pas sur la configuration statique.

RUN a2enmod ... va lancer l'utilitaire pour installer les 2 modules nécessaires pour configurer le proxy sur notre serveur.

RUN a2ensite ... va activer les deux sites que nous avons copié précédemment.

``
<VirtualHost *:80>
</VirtualHost>
``

* 001-reverse-proxy.conf qui défini les paramètres du routage vers nos deux containers.

``
<VirtualHost *:80>
        ServerName demo.res.ch

        ProxyPass "/api/presences/" "http://172.17.0.3:3000/"
        ProxyPassReverse "/api/presences/" "http://172.17.0.3:3000/"

        ProxyPass "/" "http://172.17.0.2:80/"
        ProxyPassReverse "/" "http://172.17.0.2:80/"
</VirtualHost>
``
Dans ce fichier, on peut voir qu'on spécifie le ServerName, donc le contenu de l'en-tête Host: attendu, Proxy Pass va spécifier une réécriture de l'url. Donc quand le client envoie "/api/presences/" au reverse proxy, celui-ci va faire passer l'URL "http://172.17.0.3:3000/" et ainsi permettre d'être opaque sur la structure présente derrière lui.

A l'inverse on réécrit l'URL de base pour les réponses venant dans l'autre sens.


Nous allons ensuite générer notre image via la commande docker build sous le nom "apache-rp".
Puis nous allons lancer un container avec la commande suivante.

``
docker run -d -p 8080:80 apache-rp
``

#### Vérification du fonctionnement correct de nos routes

Si on tape l'adresse ip de la VM Docker avec le port 8080, on atteint bien une page d'interdiction d'accès. En effet, on suit le sous-site par défaut 000.

Il faut maintenant configurer le nom DNS demo.res.ch dans notre fichier hosts pour le faire correspondre à l'adresse ip de notre VM. Pour celà et sous Windows, il faut aller sous C:\Windows\System32\drivers\etc\hosts et insérer la ligne suivante dans le fichier.

``
192.168.99.100 demo.res.ch
``












configuration host 192.168.99.100 demo.res.ch et test ping

## Step 4: AJAX requests with JQuery

## Step 5: Dynamic reverse proxy configuration
